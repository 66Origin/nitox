use crate::protocol::{Command, CommandError};
use bytes::{BufMut, Bytes, BytesMut};
use rand::{distributions::Alphanumeric, thread_rng, Rng};

/// SUB initiates a subscription to a subject, optionally joining a distributed queue group.
#[derive(Debug, Clone, PartialEq, Builder)]
#[builder(build_fn(validate = "Self::validate"))]
pub struct SubCommand {
    /// The subject name to subscribe to
    #[builder(setter(into))]
    pub subject: String,
    /// If specified, the subscriber will join this queue group
    #[builder(default)]
    pub queue_group: Option<String>,
    /// A unique alphanumeric subscription ID, generated by the client
    #[builder(setter(into), default = "SubCommand::generate_sid()")]
    pub sid: String,
}

impl SubCommand {
    pub fn builder() -> SubCommandBuilder {
        SubCommandBuilder::default()
    }

    /// Generates a random `sid` `String`
    pub fn generate_sid() -> String {
        thread_rng().sample_iter(&Alphanumeric).take(12).collect()
    }
}

impl Command for SubCommand {
    const CMD_NAME: &'static [u8] = b"SUB";

    fn into_vec(self) -> Result<Bytes, CommandError> {
        let (qg_len, qg) = self.queue_group.map_or((0, "".into()), |qg| (qg.len() + 1, qg));
        let len = 7 + self.subject.len() + qg_len + self.sid.len();
        let mut bytes = BytesMut::with_capacity(len);
        bytes.put("SUB\t");
        bytes.put(self.subject);
        if qg_len > 0 {
            bytes.put_u8(b'\t');
            bytes.put(qg);
        }
        bytes.put_u8(b'\t');
        bytes.put(self.sid);
        bytes.put("\r\n");

        Ok(bytes.freeze())
    }

    fn try_parse(buf: Bytes) -> Result<Self, CommandError> {
        let len = buf.len();

        if buf[len - 2..] != [b'\r', b'\n'] {
            return Err(CommandError::IncompleteCommandError);
        }

        let mut split = buf[..len - 2].split(|c| *c == b' ' || *c == b'\t');
        let cmd = split.next().ok_or_else(|| CommandError::CommandMalformed)?;
        // Check if we're still on the right command
        if cmd != Self::CMD_NAME {
            return Err(CommandError::CommandMalformed);
        }

        // Extract subject
        let subject: String = std::str::from_utf8(split.next().ok_or_else(|| CommandError::CommandMalformed)?)?.into();
        // Extract subscription id
        let sid: String = std::str::from_utf8(split.next_back().ok_or_else(|| CommandError::CommandMalformed)?)?.into();
        // Extract queue group if exists
        let queue_group: Option<String> = match split.next() {
            Some(v) => Some(std::str::from_utf8(v)?.into()),
            _ => None,
        };

        Ok(SubCommand {
            subject,
            queue_group,
            sid,
        })
    }
}

impl SubCommandBuilder {
    fn validate(&self) -> Result<(), String> {
        if let Some(ref subj) = self.subject {
            check_cmd_arg!(subj, "subject");
        }

        if let Some(ref qg_maybe) = self.queue_group {
            if let Some(ref qg) = qg_maybe {
                check_cmd_arg!(qg, "queue group");
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::{SubCommand, SubCommandBuilder};
    use crate::protocol::Command;

    static DEFAULT_SUB: &'static str = "SUB\tFOO\tpouet\r\n";

    #[test]
    fn it_parses() {
        let parse_res = SubCommand::try_parse(DEFAULT_SUB.into());
        assert!(parse_res.is_ok());
        let cmd = parse_res.unwrap();
        assert_eq!(cmd.subject, "FOO");
        assert_eq!(cmd.sid, "pouet")
    }

    #[test]
    fn it_stringifies() {
        let cmd = SubCommandBuilder::default()
            .subject("FOO")
            .sid("pouet")
            .build()
            .unwrap();

        let cmd_bytes_res = cmd.into_vec();
        assert!(cmd_bytes_res.is_ok());
        let cmd_bytes = cmd_bytes_res.unwrap();

        assert_eq!(DEFAULT_SUB, cmd_bytes);
    }
}
